#!/usr/bin/env mpipython
"""
Usage: graph_merge_lam.py [OPTION] INPUTDIR OUTPUTFILE

Option:
	INPUTDIR is the directory containing all the graph files in gspan format.
	OUTPUTFILE is the file to store the merged graphs also in gspan format.
	-s ..., --support=...	minimum support for the edge to be kept. 5(default)
	-t ..., --threshold=...	the size of graph_dict, 1000,000(default)
	-h, --help              show this help
	
Examples:
	graph_merge_lam.py -s 6 gph_result/sc/ gph_result/sc_mcl/mcl_gph_dataset1

Description:
	This program merges all the graphs in gspan format, generated by
	graph_reorganize.py. The ouput is also in gspan format.
	After this, either run reverse+kMax or gspan2mcl_input.py+mcl to
	get the dense clusters.
	
	03-13-05
		lam/mpi version of graph_merge.py

"""


from Scientific import MPI
import sys, os, re, getopt

class graph_merge:
	'''
	03-13-05
		the lam/mpi version of graph_merge
	'''
	def __init__(self, support, threshold, dir, ofname):
		self.support = int(support)
		self.threshold = int(threshold)
		self.dir = dir
		self.ofname = ofname
		#data structure to store the merged graph. key is the edge.
		#value is the recurrence
		self.graph_dict = {}
	
	def check_edge(self, edge_name, communicator):
		"""
		03-13-05
			input: an edge
			output: either '-1'(incremented) or a threshold_indicator_list
			
			check which node has this edge, 
			if that node	has it, increment its counter in its graph_dict, return '-1' meaning 'incremented'
						not have it, return '1' or '0' indicating whether its graph_dict reaches memory threshold.
		"""
		threshold_indicator_list = []
		for dest in range(1,communicator.size):
			communicator.send(edge_name, dest, dest)
			data, source, tag = communicator.receiveString(dest, None)
			if data=="-1":
				return data
			else:
				threshold_indicator_list.append(data)
		return threshold_indicator_list
	
	def add_edge(self, edge_name, threshold_indicator_list, communicator):
		"""
		03-13-05
			input: edge_name and threshold_indicator_list
			output: "no space" or "added" or "unknown error"
			
			find a node through threshold_indicator_list, which doesn't reach memory threshold
		"""
		#default return is "no space"
		return_value = "no space"
		for dest in range(1,communicator.size):
			threshold_indicator = threshold_indicator_list[dest-1]
			if threshold_indicator=='0':
				#found one node
				communicator.send("new,%s"%(edge_name), dest, dest)
				return_value, source, tag = communicator.receiveString(dest, None)
				break
				
		return return_value

	def output(self, ofname, first_block, support, communicator):
		"""
		03-13-05
			input: first_block, support, communicator
			no output:
			
			first output the first_block,
			then tell each node to output its graph_dict given a support
		"""
		#output the preceding block first
		of = open(ofname, 'w')
		of.write(first_block)
		of.close()
		for dest in range(1,communicator.size):
			communicator.send("output", dest, dest)
			return_value, source, tag = communicator.receiveString(dest, None)
			if return_value=="1":
				print "%s finished its output"%(source)
			else:
				print "%s encounted error: %s in its output"%(source, return_value)
	
	def edge_loadin(self, dir, communicator):
		#output block put before edges
		first_block = ''
		
		files = os.listdir(dir)
		sys.stderr.write("\tTotally, %d files to be processed.\n"%len(files))
		for f in files:
			pathname = os.path.join(dir, f)
			sys.stderr.write("%d/%d:\t%s\n"%(files.index(f)+1,len(files),f))
			file_no = files.index(f)+1
			inf = open(pathname, 'r')
			for line in inf:
				if line[0] == 'e':
					#edge here, like 'e 3807 3859 0.804645'
					line_list = line[:-1].split()
					vertex1 = int(line_list[1])
					vertex2 = int(line_list[2])
					if vertex1 <= vertex2:
						edge = '%s,%s'%(vertex1,vertex2)
					else:
						edge = '%s,%s'%(vertex2, vertex1)
					check_return_value = self.check_edge(edge, communicator)
					if check_return_value != '-1':
						#new edge
						add_return_value = self.add_edge(edge, check_return_value, communicator)
					if add_return_value!='added':
						sys.stderr.write("Error encounted when adding an edge: %s\n"%add_return_value)
				elif file_no == 1:
					first_block += line
			inf.close()
		
		return first_block
	
	def node_output(self, ofname, support, communicator):
		"""
		03-13-05
			input: ofname, support, communicator
			no output:
			
			This function is for all secondary nodes.
			It outputs its graph_dict.
		"""
		sys.stderr.write("%s is outputing its graph_dict..."%communicator.rank)
		#NOTE: It's 'a' not 'w'. 'w' overwrites output() of the primary node.
		of = open(ofname, 'a')
		for edge in self.graph_dict.keys():
			recurrence = self.graph_dict[edge]
			if recurrence >= support:
				of.write("e %d %d %d\n"%(edge[0], edge[1], recurrence))
		#don't forget to close it
		of.close()
		sys.stderr.write("Done\n")
		
	def node_loop(self, ofname, support, threshold, communicator):
		"""
		03-13-05
			This is a message capturing loop for each secondary node.
			They function according to the message.
		"""
		while 1:
			data, source, tag = communicator.receiveString(0, None)
			if data=="output":
				self.node_output(ofname, support, communicator)
				communicator.send("1",0,1)
				sys.exit(0)
			else:
				data = data.split(',')
				if data[0] == 'new':
					#create an edge tuple
					edge = (int(data[1]), int(data[2]))
					self.graph_dict[edge] = 1
					communicator.send("added", 0, 2)
				else:
					#create an edge tupple
					edge = (int(data[0]), int(data[1]))
					if edge in self.graph_dict:
						#present, increment its counter
						self.graph_dict[edge] += 1
						communicator.send("-1",0, 3)
					else:
						#not present
						if len(self.graph_dict)<threshold:
							#not full
							communicator.send("0",0,4)
						else:
							#full
							communicator.send("1",0,5)
	
	def run(self):
		"""
		03-13-05
			the central coordinator
			
			rank==0
				--edge_loadin()
					--check_edge()
					--add_edge()
				--ouput()
			rank==1
				--node_loop()
					--node_output()
		"""
		communicator = MPI.world.duplicate()
		
		if communicator.rank == 0:
			first_block = self.edge_loadin(self.dir, communicator)
			self.output(self.ofname, first_block, self.support, communicator)
		else:
			self.node_loop(self.ofname, self.support, self.threshold, communicator)
			
	
if __name__ == '__main__':
	if len(sys.argv) == 1:
		print __doc__
		sys.exit(2)
		
	try:
		opts, args = getopt.getopt(sys.argv[1:], "s:t:h", ["support=", "threshold=", "help"])
	except:
		print __doc__
		sys.exit(2)
	
	support = 5
	threshold = 1000000
	for opt, arg in opts:
		if opt in ("-s", "--support"):
			support = int(arg)
		elif opt in ("-t", "--threshold"):
			threshold = int(arg)
		elif opt in ("-h", "--help"):
			print __doc__
			sys.exit(2)

			
	if len(args) == 2:
		instance = graph_merge(support, threshold, args[0], args[1])
		instance.run()
	else:
		print __doc__
		sys.exit(2)
